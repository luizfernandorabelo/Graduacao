# Aplicação do Algoritmo RSA para mensagens inteiras

secret_prime_1 =259117086013202627776246767922441530941818887553125427303974923161874019266586362086201209516800483406550695241733194177441689509238807017410377709597512042313066624082916353517952311186154862265604547691127595848775610568757931191017711408826252153849035830401185072116424747461823031471398340229288074545677907941037288235820705892351068433882986888616658650280927692080339605869308790500409503709875902119018371991620994002568935113136548829739112656797303241986517250116412703509705427773477972349821676443446668383119322540099648994051790241624056519054483690809616061625743042361721863339415852426431208737266591962061753535748892894599629195183082621860853400937932839420261866586142503251450773096274235376822938649407127700846077124211823080804139298087057504713825264571448379371125032081826126566649084251699453951887789613650248405739378594599444335231188280123660406262468609212150349937584782292237144339628858485938215738821232393687046160677362909315071

secret_prime_2 =1475979915214180235084898622737381736312066145333169775147771216478570297878078949377407337049389289382748507531496480477281264838760259191814463365330269540496961201113430156902396093989090226259326935025281409614983499388222831448598601834318536230923772641390209490231836446899608210795482963763094236630945410832793769905399982457186322944729636418890623372171723742105636440368218459649632948538696905872650486914434637457507280441823676813517852099348660847172579408422316678097670224011990280170474894487426924742108823536808485072502240519452587542875349976558572670229633962575212637477897785501552646522609988869914013540483809865681250419497686697771007

public_n = secret_prime_1 * secret_prime_2

secret_phi = (secret_prime_1 - 1) * (secret_prime_2 - 1)

public_e = 3791411834614679231231687303715874105723 # escolhido de forma que gcd(secret_phi, e) = 1

secret_e_inverse = 331280727588691127850384958909638322705325557068241658016296776458985992040035955181692249103805411140079084631845777218634639806013326621228863773681550528256907316830191267464958503611923185667526956363708533025393852127398162847898988086145724015593711224002919674200245195216825629341200807190110060288245774196619204091046604861022651302783113395637852954253724487709807082297170293321831580790799589100615257829652027335626752622743618072541074167832606938857901360636914969706858967812365961853551081189538374190194744075190733163565199538938335246477332244908104930102899331264125973231253358723154843901249968510378991920589163210167130365941710016977199476392785888757463785836186797683388214058837432779456133101381738304142775193357827913436869012762673374394869876871241499552164635877812350520358259788671089569299603562737365716693219360198286833999154309259444885281300862073025025422410149313764386112001605923273713098953665530144420132092849592704589245960285941748236225193314891954413113175170479429685972542919097826343276274349963428965945572100491961698130672927176150700787531502053029057994996678257004960233746058296689198258511129751061403794121878920447681814359009185148506882763006664456271197982894905958946783606385227182431152752320642407031022952491680103678502464108684314413846372999386437071569857261010557840677893111962917689530969527781385794397927537315085472417887932841437099993722148340187417276870639918340937520961421948845594528355230976542998581447391377020853757814554822213324515315398450076273191043209858153625599735363519572694592294079052304032295851144206474482529518290041387 # e⁻¹ mod(secret_phi)


def to_binary(integer):

    assert integer >= 0

    binary = []
    index = 0
    total = integer

    if total == 0:
        binary.append(0)
        return binary

    while total > 0:
        remainder = int(total % 2)
        binary.append(remainder)
        total //= 2

    return binary


def get_remainder_list(b, len_binary_e, n):

    assert len_binary_e > 0

    remainders = []

    remainders.append(b % n)

    for i in range(1, len_binary_e):
        remainders.append((remainders[i-1] ** 2) % n)
    
    return remainders


def multiplicate_remainders(binary_e, remainder_list, n):

    len_binary_e = len(binary_e)

    assert len_binary_e > 0

    final_remainder = 1

    for i in range(len_binary_e):
        if binary_e[i] == 1:
            final_remainder = (final_remainder * remainder_list[i]) % n
    
    return final_remainder
    

def modular_exponentiation(b, e, n):

    r = e % (n - 1)

    binary_r = to_binary(r)
    remainder_list = get_remainder_list(b, len(binary_r), n)

    return multiplicate_remainders(binary_r, remainder_list, n)


def encode(message):
    return modular_exponentiation(message, public_e, public_n)


def decode(message):
    return modular_exponentiation(message, secret_e_inverse, public_n)


def main():

    message = int(input('m: '))

    encoded = encode(message)
    print(f'Mensagem codificada = {encoded}')

    decoded = decode(encoded)    
    print(f'Mensagem decodificada = {decoded}')


if __name__ == '__main__':
    main()
